<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c/c++ on My Universe</title><link>https://daemotron.github.io/tags/c/c++/</link><description>Recent content in c/c++ on My Universe</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><atom:link href="https://daemotron.github.io/tags/c/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>Configuration File with XPPL</title><link>https://daemotron.github.io/2023/09/23/configuration-file-with-xppl/</link><pubDate>Sat, 23 Sep 2023 00:00:00 +0000</pubDate><guid>https://daemotron.github.io/2023/09/23/configuration-file-with-xppl/</guid><description>In this blog post we&amp;rsquo;re looking into using XPPL to enhance a plugin with a configuration file. Working with XPPL&amp;rsquo;s configuration module is follows this five-step sequence:
initialize a configuration context register configuration properties load the configuration file access the configuration values clean up First, we need a configuration context. Since we will need to keep it alive throughout the whole plugin life cycle, we declare it as static, global variable:</description></item><item><title>Introducing XPPL</title><link>https://daemotron.github.io/2023/09/22/introducing-xppl/</link><pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate><guid>https://daemotron.github.io/2023/09/22/introducing-xppl/</guid><description>Are you tired of (re-)writing the same boilerplace code for every X-Plane plugin project &amp;mdash; over and over again? Well, at least that&amp;rsquo;s how I felt when I started my fourth or fifth plugin. Sure, I reused a lot of my boilerplate code, but with every project, I refined and enhanced it. Backporting those changes to older plugins became a tedious task though; therefore I started the X-Plane Plugin Library (XPPL).</description></item><item><title>Cache Your Datarefs</title><link>https://daemotron.github.io/2023/04/20/cache-your-datarefs/</link><pubDate>Thu, 20 Apr 2023 22:20:48 +0200</pubDate><guid>https://daemotron.github.io/2023/04/20/cache-your-datarefs/</guid><description>Nearly every X-Plane plugin accesses one or several of X-Plane&amp;rsquo;s datarefs at runtime. It&amp;rsquo;s not uncommon to find code like this:
1void set_data(float value) 2{ 3 XPLMDataRef dref = XPLMFindDataRef(&amp;#34;what/ever/data/ref/we/need&amp;#34;); 4 XPLMSetDataf(dref, value); 5} Admittedly this works. However, there are a couple of reasons why the code above is not the best idea, if you&amp;rsquo;re seeking to write a solid and well-performing plugin:
The code doesn&amp;rsquo;t check if dref actually points to a dataref before attempting to write to it The caller doesn&amp;rsquo;t get notified about success or failure of the operation XPLMFindDataRef is expensive, and should be used only during plugin initialisation In fact, also X-Plane&amp;rsquo;s SDK documentation emphasizes the third point:</description></item><item><title>Talk to the Log</title><link>https://daemotron.github.io/2023/01/14/talk-to-the-log/</link><pubDate>Sat, 14 Jan 2023 19:51:48 +0100</pubDate><guid>https://daemotron.github.io/2023/01/14/talk-to-the-log/</guid><description>Making an X-Plane plugin &amp;ldquo;talk&amp;rdquo; to us is one of the boilerplate tasks when setting up a new plugin project. X-Plane has its own log file, log.txt, which is found in X-Plane&amp;rsquo;s root folder. The file gets reset every time X-Plane starts, so there&amp;rsquo;s no need to rotate or trim it from time to time. As a plugin author, we have the choice to either write our own log file, or to jump on X-Plane&amp;rsquo;s bandwagon and use its logging system for our purposes.</description></item><item><title>CMake Linux Hack</title><link>https://daemotron.github.io/2023/01/11/cmake-linux-hack/</link><pubDate>Wed, 11 Jan 2023 00:16:46 +0100</pubDate><guid>https://daemotron.github.io/2023/01/11/cmake-linux-hack/</guid><description>Beginning with its most recent version (3.25 at the time of writing this post), CMake provides the LINUX variable, which I used in my previous post. Of course, developers on Linux tend to use the version of CMake they can install from their distribution&amp;rsquo;s package manager. On Ubuntu 22.04 LTS that would be 3.22, and even on the most recent Ubuntu version (22.10) we&amp;rsquo;re at 3.24 &amp;mdash; meaning this variable is not available in these CMake versions.</description></item><item><title>X-Plane Plugin Boilerplate</title><link>https://daemotron.github.io/2023/01/04/x-plane-plugin-boilerplate/</link><pubDate>Wed, 04 Jan 2023 15:28:28 +0100</pubDate><guid>https://daemotron.github.io/2023/01/04/x-plane-plugin-boilerplate/</guid><description>X-Plane has a well-documented, accessible API, making it relatively easy to write plugins for the simulator. In this post I&amp;rsquo;m going to demonstrate how a basic plugin boilerplate can look like, and how to build it on different platforms.
Let&amp;rsquo;s get started with some basics: X-Plane plugins are dynamically linked libraries, which are loaded by X-Plane at runtime. They have to provide an API as defined by the X-Plane SDK, so X-Plane can access the plugin via defined entry points.</description></item></channel></rss>